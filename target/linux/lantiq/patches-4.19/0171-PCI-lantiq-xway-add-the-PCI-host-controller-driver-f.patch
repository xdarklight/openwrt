From 6570301a431909da018fc0924ca4ef49f845e2e5 Mon Sep 17 00:00:00 2001
From: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date: Thu, 11 Jul 2019 13:48:27 +0200
Subject: [PATCH 4/5] PCI: lantiq-xway: add the PCI host controller driver for
 Lantiq XWAY SoCs - WiP

WiP: commit message
+ legacy DT-bindings handling

Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
---
 drivers/pci/controller/Kconfig           |   8 +
 drivers/pci/controller/Makefile          |   1 +
 drivers/pci/controller/pci-lantiq-xway.c | 393 +++++++++++++++++++++++
 3 files changed, 402 insertions(+)
 create mode 100644 drivers/pci/controller/pci-lantiq-xway.c

--- a/drivers/pci/controller/Kconfig
+++ b/drivers/pci/controller/Kconfig
@@ -263,6 +263,14 @@ config PCIE_TANGO_SMP8759
 	  This can lead to data corruption if drivers perform concurrent
 	  config and MMIO accesses.
 
+config PCI_LANTIQ_XWAY
+	bool "Lantiq XWAY PCI host controller"
+	depends on (SOC_XWAY && PCI_DRIVERS_GENERIC) || COMPILE_TEST
+	depends on OF && HAS_IOMEM
+	help
+	  Say Y here if you want support for the PCI host controller found
+	  on Lantiq XWAY SoCs.
+
 config VMD
 	depends on PCI_MSI && X86_64 && SRCU
 	tristate "Intel Volume Management Device Driver"
--- a/drivers/pci/controller/Makefile
+++ b/drivers/pci/controller/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_PCIE_ROCKCHIP_HOST) += pcie
 obj-$(CONFIG_PCIE_MEDIATEK) += pcie-mediatek.o
 obj-$(CONFIG_PCIE_MOBIVEIL) += pcie-mobiveil.o
 obj-$(CONFIG_PCIE_TANGO_SMP8759) += pcie-tango.o
+obj-$(CONFIG_PCI_LANTIQ_XWAY) += pci-lantiq-xway.o
 obj-$(CONFIG_VMD) += vmd.o
 # pcie-hisi.o quirks are needed even without CONFIG_PCIE_DW
 obj-y				+= dwc/
--- /dev/null
+++ b/drivers/pci/controller/pci-lantiq-xway.c
@@ -0,0 +1,394 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Lantiq XWAY PCI host controller driver.
+ *
+ * Copyright (C) 2010 John Crispin <john@phrozen.org>
+ * Copyright (C) 2019 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ */
+
+#include <linux/bootmem.h>
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/memblock.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/reset.h>
+
+#include "../pci.h"
+
+#define PCI_CR_CLK_CTRL					0x0000
+#define PCI_CR_CLK_CTRL_FPI_CLK_DIS			BIT(0)
+#define PCI_CR_CLK_CTRL_EBU_PCI_SWITCH_EN		BIT(1)
+#define PCI_CR_CLK_CTRL_FIXED_ARB_EN			BIT(2)
+#define PCI_CR_CLK_CTRL_FPI_NORMAL_ACK			BIT(3)
+
+#define PCI_CS_BASE_ADDR1				0x0010
+#define PCI_CR_PCI_EOI					0x002c
+
+#define PCI_CR_PCI_MOD					0x0030
+#define PCI_CR_PCI_MOD_CONFIG_OK			BIT(24)
+
+#define PCI_CR_BAR11MASK				0x0044
+
+#define PCI_CR_BAR12MASK				0x0048
+#define PCI_CR_BAR12MASK_BAR_DECODING_EN		BIT(31)
+
+#define PCI_CR_BAR13MASK				0x004c
+#define PCI_CR_BAR13MASK_BAR_DECODING_EN		BIT(31)
+
+#define PCI_CR_BAR14MASK				0x0050
+#define PCI_CR_BAR14MASK_BAR_DECODING_EN		BIT(31)
+
+#define PCI_CR_BAR15MASK				0x0054
+#define PCI_CR_BAR15MASK_BAR_DECODING_EN		BIT(31)
+
+#define PCI_CR_BAR16MASK				0x0058
+#define PCI_CR_BAR16MASK_BAR_DECODING_EN		BIT(31)
+
+#define PCI_CR_PCI_ADDR_MAP11				0x0064
+#define PCI_CR_PC_ARB					0x0080
+#define PCI_CR_FPI_ADDR_MAP0				0x00c0
+#define PCI_CR_FPI_ADDR_MAP1				0x00c4
+#define PCI_CR_FPI_ADDR_MAP2				0x00c8
+#define PCI_CR_FPI_ADDR_MAP3				0x00cc
+#define PCI_CR_FPI_ADDR_MAP4				0x00d0
+#define PCI_CR_FPI_ADDR_MAP5				0x00d4
+#define PCI_CR_FPI_ADDR_MAP6				0x00d8
+#define PCI_CR_FPI_ADDR_MAP7				0x00dc
+#define PCI_CR_FPI_ADDR_MAP11_LOW			0x00e0
+#define PCI_CR_FPI_ADDR_MAP11_HIGH			0x00e4
+#define PCI_CR_FPI_BURST_LENGTH				0x00e8
+
+#define PCI_MASTER0_REQ_MASK_2BITS	8
+#define PCI_MASTER1_REQ_MASK_2BITS	10
+#define PCI_MASTER2_REQ_MASK_2BITS	12
+#define INTERNAL_ARB_ENABLE_BIT		0
+
+#define LTQ_PCI_CFG_BUSNUM_SHF		16
+#define LTQ_PCI_CFG_DEVNUM_SHF		11
+#define LTQ_PCI_CFG_FUNNUM_SHF		8
+
+#define LTQ_PCI_SLOT_SOC				0xd
+
+struct ltq_pci {
+	void __iomem		*ctrl_base;
+	void __iomem		*config_base;
+	struct gpio_desc	*reset_gpiod;
+	struct reset_control	*core_reset;
+	u32			req_mask;
+	struct clk		*pci_clk;
+	/*
+	 * TODO: pci_clk_rate can be configured by using the assigned-clocks
+	 * and assigned-clock-rates properties via devicetree once the lantiq
+	 * target is ported to the common clock framework.
+	 */
+	u32			pci_clk_rate;
+	/*
+	 * TODO: external_clk is a hack because it's a mux instead of a gate.
+	 * Drop it when porting the lantiq target over to use the common clock
+	 * framework.
+	 */
+	struct clk		*external_clk;
+};
+
+static void __iomem *ltq_pci_map_bus_internal(struct pci_bus *bus,
+					      unsigned int devfn, int where)
+{
+	struct ltq_pci *ltq_pci = bus->sysdata;
+	u32 offset;
+
+	offset = ALIGN_DOWN(where, 4);
+	offset |= (bus->number << LTQ_PCI_CFG_BUSNUM_SHF);
+	offset |= (PCI_SLOT(devfn) << LTQ_PCI_CFG_DEVNUM_SHF);
+	offset |= (PCI_FUNC(devfn) << LTQ_PCI_CFG_FUNNUM_SHF);
+
+	return ltq_pci->config_base + offset;
+}
+
+static void ltq_pci_clear_master_abort(struct pci_bus *bus)
+{
+	void __iomem *target;
+	u32 tmp;
+
+	tmp = readl(ltq_pci_map_bus_internal(bus, PCI_DEVFN(0x0, 0x0),
+					     PCI_COMMAND));
+
+	target = ltq_pci_map_bus_internal(bus,
+					  PCI_DEVFN(LTQ_PCI_SLOT_SOC, 0x0),
+					  PCI_COMMAND);
+
+	/* the SoC itself uses big endian byte-order */
+	iowrite32be(tmp, target);
+}
+
+static void __iomem *ltq_pci_map_bus(struct pci_bus *bus, unsigned int devfn,
+				     int where)
+{
+	if (bus->number != 0)
+		return 0;
+
+	if (PCI_SLOT(devfn) == 0)
+		return 0;
+
+	if (PCI_SLOT(devfn) == LTQ_PCI_SLOT_SOC)
+		return 0;
+
+	return ltq_pci_map_bus_internal(bus, devfn, where);
+}
+
+static int ltq_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+			       int where, int size, u32 *val)
+{
+	int ret;
+
+	ret = pci_generic_config_read32(bus, devfn, where, size, val);
+	if (ret)
+		return ret;
+
+	ltq_pci_clear_master_abort(bus);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ltq_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 val)
+{
+	int ret;
+
+	ret = pci_generic_config_write32(bus, devfn, where, size, val);
+	if (ret)
+		return ret;
+
+	ltq_pci_clear_master_abort(bus);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops lantiq_pci_ops = {
+	.map_bus	= ltq_pci_map_bus,
+	.read		= ltq_pci_read_config,
+	.write		= ltq_pci_write_config,
+};
+
+static inline u32 ltq_calc_bar11mask(void)
+{
+	u32 mem, bar11mask;
+
+	/* BAR11MASK value depends on available memory on system. */
+	mem = max_low_pfn << PAGE_SHIFT;
+	bar11mask = ((-roundup_pow_of_two(mem)) & 0x0f000000) | 8;
+
+	return bar11mask;
+}
+
+static void ltq_pci_startup(struct ltq_pci *ltq_pci)
+{
+	u32 temp_buffer;
+
+	/* enable auto-switching between PCI and EBU */
+	temp_buffer = PCI_CR_CLK_CTRL_EBU_PCI_SWITCH_EN;
+	temp_buffer |= PCI_CR_CLK_CTRL_FPI_NORMAL_ACK;
+	iowrite32be(temp_buffer, ltq_pci->ctrl_base + PCI_CR_CLK_CTRL);
+
+	/*
+	 * inform the hardware that configuration is not done (yet).
+	 * PCI access has to be retried.
+	 */
+	temp_buffer = ioread32be(ltq_pci->ctrl_base + PCI_CR_PCI_MOD);
+	temp_buffer &= ~PCI_CR_PCI_MOD_CONFIG_OK;
+	iowrite32be(temp_buffer, ltq_pci->ctrl_base + PCI_CR_PCI_MOD);
+
+	/* BUS Master/IO/MEM access */
+	temp_buffer = ioread32be(ltq_pci->config_base + PCI_COMMAND);
+	temp_buffer |= PCI_COMMAND_IO;
+	temp_buffer |= PCI_COMMAND_MEMORY;
+	temp_buffer |= PCI_COMMAND_MASTER;
+	iowrite32be(temp_buffer, ltq_pci->config_base + PCI_COMMAND);
+
+	/* enable external 2 PCI masters */
+	temp_buffer = ioread32be(ltq_pci->ctrl_base + PCI_CR_PC_ARB);
+	/* setup the request mask */
+	temp_buffer &= ~((ltq_pci->req_mask & 0xf) << 16);
+	/* enable internal arbiter */
+	temp_buffer |= (1 << INTERNAL_ARB_ENABLE_BIT);
+	/* enable internal PCI master reqest */
+	temp_buffer &= (~(3 << PCI_MASTER0_REQ_MASK_2BITS));
+
+	/* enable EBU request */
+	temp_buffer &= (~(3 << PCI_MASTER1_REQ_MASK_2BITS));
+
+	/* enable all external masters request */
+	temp_buffer &= (~(3 << PCI_MASTER2_REQ_MASK_2BITS));
+	iowrite32be(temp_buffer, ltq_pci->ctrl_base + PCI_CR_PC_ARB);
+
+	/* setup BAR memory regions */
+	iowrite32be(0x18000000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP0);
+	iowrite32be(0x18400000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP1);
+	iowrite32be(0x18800000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP2);
+	iowrite32be(0x18c00000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP3);
+	iowrite32be(0x19000000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP4);
+	iowrite32be(0x19400000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP5);
+	iowrite32be(0x19800000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP6);
+	iowrite32be(0x19c00000, ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP7);
+
+	iowrite32be(0x1ae00000,
+		    ltq_pci->ctrl_base + PCI_CR_FPI_ADDR_MAP11_HIGH);
+
+	iowrite32be(ltq_calc_bar11mask(),
+		    ltq_pci->ctrl_base + PCI_CR_BAR11MASK);
+
+	iowrite32be(0, ltq_pci->ctrl_base + PCI_CR_PCI_ADDR_MAP11);
+	iowrite32be(0, ltq_pci->ctrl_base + PCI_CS_BASE_ADDR1);
+
+	/* both TX and RX endian swap are enabled */
+	iowrite32be(ioread32be(ltq_pci->ctrl_base + PCI_CR_PCI_EOI) | 3,
+		    ltq_pci->ctrl_base + PCI_CR_PCI_EOI);
+
+	temp_buffer = ioread32be(ltq_pci->ctrl_base + PCI_CR_BAR12MASK);
+	temp_buffer |= PCI_CR_BAR12MASK_BAR_DECODING_EN;
+	iowrite32be(temp_buffer, ltq_pci->ctrl_base + PCI_CR_BAR12MASK);
+
+	temp_buffer = ioread32be(ltq_pci->ctrl_base + PCI_CR_BAR13MASK);
+	temp_buffer |= PCI_CR_BAR13MASK_BAR_DECODING_EN;
+	iowrite32be(temp_buffer, ltq_pci->ctrl_base + PCI_CR_BAR13MASK);
+
+	/* use 8 dw burst length */
+	iowrite32be(0x303, ltq_pci->ctrl_base + PCI_CR_FPI_BURST_LENGTH);
+
+	/* let the hardware know that we're done with the configuration */
+	temp_buffer = ioread32be(ltq_pci->ctrl_base + PCI_CR_PCI_MOD);
+	temp_buffer |= PCI_CR_PCI_MOD_CONFIG_OK;
+	iowrite32be(temp_buffer, ltq_pci->ctrl_base + PCI_CR_PCI_MOD);
+
+	/* take the PCI bus out of reset */
+	gpiod_set_value_cansleep(ltq_pci->reset_gpiod, 0);
+}
+
+static int ltq_pci_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pci_host_bridge *host;
+	struct ltq_pci *ltq_pci;
+	struct resource *res;
+	LIST_HEAD(pci_res);
+	int ret;
+
+	host = devm_pci_alloc_host_bridge(dev, sizeof(*ltq_pci));
+	if (!host)
+		return -ENOMEM;
+
+	ltq_pci = pci_host_bridge_priv(host);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	ltq_pci->ctrl_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(ltq_pci->ctrl_base))
+		return PTR_ERR(ltq_pci->ctrl_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ltq_pci->config_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(ltq_pci->config_base))
+		return PTR_ERR(ltq_pci->config_base);
+
+	ltq_pci->pci_clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(ltq_pci->pci_clk)) {
+		dev_err(dev, "failed to get 'pci' clock\n");
+		return PTR_ERR(ltq_pci->pci_clk);
+	}
+
+	ltq_pci->external_clk = devm_clk_get(dev, "external");
+	if (IS_ERR(ltq_pci->external_clk)) {
+		dev_err(dev, "failed to get 'external' pci clock\n");
+		return PTR_ERR(ltq_pci->external_clk);
+	}
+
+	ltq_pci->reset_gpiod = devm_gpiod_get_optional(dev, "reset",
+						       GPIOD_OUT_HIGH);
+	if (IS_ERR(ltq_pci->reset_gpiod)) {
+		dev_err(dev, "failed to get the 'reset-gpios'\n");
+		return PTR_ERR(ltq_pci->reset_gpiod);
+	}
+
+	ltq_pci->core_reset = devm_reset_control_get_exclusive(dev, NULL);
+	if (IS_ERR(ltq_pci->core_reset)) {
+		dev_err(dev, "failed to get the reset line\n");
+		return PTR_ERR(ltq_pci->core_reset);
+	}
+
+	ret = device_property_read_u32(dev, "lantiq,bus-clock",
+				       &ltq_pci->req_mask);
+	if (ret)
+		ltq_pci->req_mask = 0xf;
+
+	ret = device_property_read_u32(dev, "lantiq,bus-clock",
+				       &ltq_pci->pci_clk_rate);
+	if (ret)
+		/* default to 33.3MHz */
+		ltq_pci->pci_clk_rate = 33333333;
+
+	ret = clk_set_rate(ltq_pci->pci_clk, ltq_pci->pci_clk_rate);
+	if (ret) {
+		dev_err(dev, "Failed to set PCI clock to %uHz\n",
+			ltq_pci->pci_clk_rate);
+		return ret;
+	}
+
+	ret = pci_parse_request_of_pci_ranges(dev, &pci_res, &res);
+	if (ret)
+		return ret;
+
+	host->dev.parent = dev;
+	host->ops = &lantiq_pci_ops;
+	host->busnr = res->start;
+	host->msi = NULL;
+	host->map_irq = of_irq_parse_and_map_pci;
+	host->swizzle_irq = pci_common_swizzle;
+	host->sysdata = ltq_pci;
+	list_splice_init(&pci_res, &host->windows);
+
+	ret = clk_prepare_enable(ltq_pci->pci_clk);
+	if (ret) {
+		dev_err(dev, "failed to enable the 'pci' clock\n");
+		return ret;
+	}
+
+	if (device_property_read_bool(dev, "lantiq,external-clock"))
+		clk_enable(ltq_pci->external_clk);
+	else
+		clk_disable(ltq_pci->external_clk);
+
+	ltq_pci_startup(ltq_pci);
+
+	ret = pci_scan_root_bus_bridge(host);
+	if (ret) {
+		dev_err(dev, "failed to scan host: %d\n", ret);
+		return ret;
+	}
+
+	pci_bus_assign_resources(host->bus);
+	pci_bus_add_devices(host->bus);
+
+	return 0;
+}
+
+static const struct of_device_id ltq_pci_match[] = {
+	{ .compatible = "lantiq,pci-xway" }, /* DEPRECATED */
+	{ .compatible = "lantiq,arx100-pci" },
+	{ .compatible = "lantiq,danube-pci" },
+	{ .compatible = "lantiq,vrx200-pci" },
+	{ /* sentinel */ },
+};
+
+static struct platform_driver ltq_pci_driver = {
+	.probe = ltq_pci_probe,
+	.driver = {
+		.name = "pci-lantiq-xway",
+		.of_match_table = of_match_ptr(ltq_pci_match),
+	},
+};
+builtin_platform_driver(ltq_pci_driver);
