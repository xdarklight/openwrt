From 8c840af8d156ecc8aa8d3f8aec22a8b33fef611d Mon Sep 17 00:00:00 2001
From: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
Date: Tue, 5 Jan 2021 19:01:15 +0100
Subject: [PATCH 1/2] MIPS: lantiq: use a generic "EBU" driver for Falcon and
 XWAY SoCs

Both SoC types have the EBU registers and exposing the ltq_ebu_membase
in (the SoC-independent) arch/mips/include/asm/mach-lantiq/lantiq.h.
The only difference is the initialization logic: XWAY clears the WRDIS
(write disable) bit of the BUSCON0 register, while Falcon leaves it as
is.

Move the existing EBU logic from the Falcon and XWAY SoC types into a
generic driver.
This will make it easier to add the PCI irq controller which is provided
by EBU on at least the XWAY SoCs.

No functional changes intended.

Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
---
 .../include/asm/mach-lantiq/xway/lantiq_soc.h |   2 -
 arch/mips/lantiq/Makefile                     |   2 +-
 arch/mips/lantiq/ebu.c                        | 101 ++++++++++++++++++
 arch/mips/lantiq/falcon/sysctrl.c             |  16 +--
 arch/mips/lantiq/xway/sysctrl.c               |  21 +---
 5 files changed, 111 insertions(+), 31 deletions(-)
 create mode 100644 arch/mips/lantiq/ebu.c

--- a/arch/mips/include/asm/mach-lantiq/xway/lantiq_soc.h
+++ b/arch/mips/include/asm/mach-lantiq/xway/lantiq_soc.h
@@ -79,13 +79,11 @@ extern __iomem void *ltq_cgu_membase;
 #define LTQ_EARLY_ASC		KSEG1ADDR(LTQ_ASC1_BASE_ADDR)
 
 /* EBU - external bus unit */
-#define LTQ_EBU_BUSCON0		0x0060
 #define LTQ_EBU_PCC_CON		0x0090
 #define LTQ_EBU_PCC_IEN		0x00A4
 #define LTQ_EBU_PCC_ISTAT	0x00A0
 #define LTQ_EBU_BUSCON1		0x0064
 #define LTQ_EBU_ADDRSEL1	0x0024
-#define EBU_WRDIS		0x80000000
 
 /* WDT */
 #define LTQ_RST_CAUSE_WDTRST	0x20
--- a/arch/mips/lantiq/Makefile
+++ b/arch/mips/lantiq/Makefile
@@ -2,7 +2,7 @@
 # Copyright (C) 2010 John Crispin <john@phrozen.org>
 #
 
-obj-y := irq.o clk.o prom.o
+obj-y := irq.o clk.o ebu.o prom.o
 
 obj-$(CONFIG_EARLY_PRINTK) += early_printk.o
 
--- /dev/null
+++ b/arch/mips/lantiq/ebu.c
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *  Copyright (C) 2019 Martin Blumenstingl <martin.blumenstingl@googlemail.com>
+ *  Copyright (C) 2011-2012 John Crispin <blogic@openwrt.org>
+ */
+
+#include <linux/bits.h>
+#include <linux/export.h>
+#include <linux/ioport.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+
+#include <lantiq_soc.h>
+
+#define LTQ_EBU_BUSCON0				0x0060
+#define LTQ_EBU_BUSCON_WRDIS			BIT(31)
+
+void __iomem *ltq_ebu_membase;
+
+struct ltq_ebu_data {
+	bool		initialize_buscon0_wrdis;
+};
+
+static const struct ltq_ebu_data ltq_ebu_falcon_data = {
+	.initialize_buscon0_wrdis = false,
+};
+
+static const struct ltq_ebu_data ltq_ebu_xway_data = {
+	.initialize_buscon0_wrdis = true,
+};
+
+static const struct of_device_id of_ebu_ids[] __initconst = {
+	{
+		/* DEPRECATED */
+		.compatible = "lantiq,ebu-falcon",
+		.data = &ltq_ebu_falcon_data,
+	},
+	{
+		.compatible = "lantiq,falcon-ebu",
+		.data = &ltq_ebu_falcon_data,
+	},
+	{
+		/* DEPRECATED */
+		.compatible = "lantiq,ebu-xway",
+		.data = &ltq_ebu_xway_data,
+	},
+	{
+		.compatible = "lantiq,ase-ebu",
+		.data = &ltq_ebu_xway_data,
+	},
+	{
+		.compatible = "lantiq,danube-ebu",
+		.data = &ltq_ebu_xway_data,
+	},
+	{
+		.compatible = "lantiq,xrx100-ebu",
+		.data = &ltq_ebu_xway_data,
+	},
+	{
+		.compatible = "lantiq,xrx200-ebu",
+		.data = &ltq_ebu_xway_data,
+	},
+	{ /* sentinel */ },
+};
+
+static int __init ltq_ebu_setup(void)
+{
+	const struct ltq_ebu_data *ebu_data;
+	const struct of_device_id *match;
+	struct resource res_ebu;
+	struct device_node *np;
+	u32 val;
+
+	np = of_find_matching_node_and_match(NULL, of_ebu_ids, &match);
+	if (!np)
+		panic("Failed to load the EBU node from devicetree");
+
+	if (of_address_to_resource(np, 0, &res_ebu))
+		panic("Failed to get the EBU resources");
+
+	if ((request_mem_region(res_ebu.start, resource_size(&res_ebu),
+				res_ebu.name) < 0))
+		pr_err("Failed to request the EBU resources");
+
+	ltq_ebu_membase = ioremap_nocache(res_ebu.start,
+						resource_size(&res_ebu));
+	if (!ltq_ebu_membase)
+		panic("Failed to remap the EBU resources");
+
+	ebu_data = match->data;
+
+	if (ebu_data && ebu_data->initialize_buscon0_wrdis) {
+		val = ltq_ebu_r32(LTQ_EBU_BUSCON0) & ~LTQ_EBU_BUSCON_WRDIS;
+		ltq_ebu_w32(val, LTQ_EBU_BUSCON0);
+	}
+
+	return 0;
+}
+
+arch_initcall(ltq_ebu_setup);
--- a/arch/mips/lantiq/falcon/sysctrl.c
+++ b/arch/mips/lantiq/falcon/sysctrl.c
@@ -70,7 +70,7 @@
 #define status_r32(x)		ltq_r32(status_membase + (x))
 
 static void __iomem *sysctl_membase[3], *status_membase;
-void __iomem *ltq_sys1_membase, *ltq_ebu_membase;
+void __iomem *ltq_sys1_membase;
 
 void falcon_trigger_hrst(int level)
 {
@@ -184,23 +184,20 @@ void __init ltq_soc_init(void)
 {
 	struct device_node *np_status =
 		of_find_compatible_node(NULL, NULL, "lantiq,status-falcon");
-	struct device_node *np_ebu =
-		of_find_compatible_node(NULL, NULL, "lantiq,ebu-falcon");
 	struct device_node *np_sys1 =
 		of_find_compatible_node(NULL, NULL, "lantiq,sys1-falcon");
 	struct device_node *np_syseth =
 		of_find_compatible_node(NULL, NULL, "lantiq,syseth-falcon");
 	struct device_node *np_sysgpe =
 		of_find_compatible_node(NULL, NULL, "lantiq,sysgpe-falcon");
-	struct resource res_status, res_ebu, res_sys[3];
+	struct resource res_status, res_sys[3];
 	int i;
 
 	/* check if all the core register ranges are available */
-	if (!np_status || !np_ebu || !np_sys1 || !np_syseth || !np_sysgpe)
+	if (!np_status || !np_sys1 || !np_syseth || !np_sysgpe)
 		panic("Failed to load core nodes from devicetree");
 
 	if (of_address_to_resource(np_status, 0, &res_status) ||
-			of_address_to_resource(np_ebu, 0, &res_ebu) ||
 			of_address_to_resource(np_sys1, 0, &res_sys[0]) ||
 			of_address_to_resource(np_syseth, 0, &res_sys[1]) ||
 			of_address_to_resource(np_sysgpe, 0, &res_sys[2]))
@@ -208,8 +205,6 @@ void __init ltq_soc_init(void)
 
 	if ((request_mem_region(res_status.start, resource_size(&res_status),
 				res_status.name) < 0) ||
-		(request_mem_region(res_ebu.start, resource_size(&res_ebu),
-				res_ebu.name) < 0) ||
 		(request_mem_region(res_sys[0].start,
 				resource_size(&res_sys[0]),
 				res_sys[0].name) < 0) ||
@@ -223,10 +218,7 @@ void __init ltq_soc_init(void)
 
 	status_membase = ioremap(res_status.start,
 					resource_size(&res_status));
-	ltq_ebu_membase = ioremap(res_ebu.start,
-					resource_size(&res_ebu));
-
-	if (!status_membase || !ltq_ebu_membase)
+	if (!status_membase)
 		panic("Failed to remap core resources");
 
 	for (i = 0; i < 3; i++) {
--- a/arch/mips/lantiq/xway/sysctrl.c
+++ b/arch/mips/lantiq/xway/sysctrl.c
@@ -149,7 +149,6 @@ static u32 pmu_clk_cr_b[] = {
 
 static void __iomem *pmu_membase;
 void __iomem *ltq_cgu_membase;
-void __iomem *ltq_ebu_membase;
 
 static u32 ifccr = CGU_IFCCR;
 static u32 pcicr = CGU_PCICR;
@@ -410,42 +409,32 @@ static void clkdev_add_clkout(void)
 /* bring up all register ranges that we need for basic system control */
 void __init ltq_soc_init(void)
 {
-	struct resource res_pmu, res_cgu, res_ebu;
+	struct resource res_pmu, res_cgu;
 	struct device_node *np_pmu =
 			of_find_compatible_node(NULL, NULL, "lantiq,pmu-xway");
 	struct device_node *np_cgu =
 			of_find_compatible_node(NULL, NULL, "lantiq,cgu-xway");
-	struct device_node *np_ebu =
-			of_find_compatible_node(NULL, NULL, "lantiq,ebu-xway");
 
 	/* check if all the core register ranges are available */
-	if (!np_pmu || !np_cgu || !np_ebu)
+	if (!np_pmu || !np_cgu)
 		panic("Failed to load core nodes from devicetree");
 
 	if (of_address_to_resource(np_pmu, 0, &res_pmu) ||
-			of_address_to_resource(np_cgu, 0, &res_cgu) ||
-			of_address_to_resource(np_ebu, 0, &res_ebu))
+			of_address_to_resource(np_cgu, 0, &res_cgu))
 		panic("Failed to get core resources");
 
 	if (!request_mem_region(res_pmu.start, resource_size(&res_pmu),
 				res_pmu.name) ||
 		!request_mem_region(res_cgu.start, resource_size(&res_cgu),
-				res_cgu.name) ||
-		!request_mem_region(res_ebu.start, resource_size(&res_ebu),
-				res_ebu.name))
+				res_cgu.name))
 		pr_err("Failed to request core resources");
 
 	pmu_membase = ioremap(res_pmu.start, resource_size(&res_pmu));
 	ltq_cgu_membase = ioremap(res_cgu.start,
 						resource_size(&res_cgu));
-	ltq_ebu_membase = ioremap(res_ebu.start,
-						resource_size(&res_ebu));
-	if (!pmu_membase || !ltq_cgu_membase || !ltq_ebu_membase)
+	if (!pmu_membase || !ltq_cgu_membase)
 		panic("Failed to remap core resources");
 
-	/* make sure to unprotect the memory region where flash is located */
-	ltq_ebu_w32(ltq_ebu_r32(LTQ_EBU_BUSCON0) & ~EBU_WRDIS, LTQ_EBU_BUSCON0);
-
 	/* add our generic xway clocks */
 	clkdev_add_pmu("10000000.fpi", NULL, 0, 0, PMU_FPI);
 	clkdev_add_pmu("1e100a00.gptu", NULL, 1, 0, PMU_GPT);
